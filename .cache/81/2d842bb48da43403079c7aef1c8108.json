{"id":"index.html","dependencies":[{"name":"./src\\index.ts","dynamic":true,"resolved":"F:\\Projects\\2024\\Learning\\test\\House_threejs\\src\\index.ts","parent":"F:\\Projects\\2024\\Learning\\test\\House_threejs\\index.html"}],"generated":{"html":"<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <title>Fat Lines - Conditional Edges + thresholdAngle</title>\r\n    <meta charset=\"UTF-8\">\r\n  </head>\r\n\r\n  <body>\r\n    <div id=\"timeofday\">timeofday</div>\r\n    <div id=\"app\"></div>\r\n\r\n    <script id=\"stripes-vertexShader\" type=\"x-shader/x-vertex\">\r\n      #define GLSLIFY 1\r\n      // Common varyings\r\n      varying vec3 v_position;\r\n      varying vec3 v_normal;\r\n\r\n      /*\r\n       * The main program\r\n       */\r\n      void main() {\r\n          // Save the varyings\r\n          v_position = position;\r\n          v_normal = normalize(normalMatrix * normal);\r\n\r\n          // Vertex shader output\r\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    </script>\r\n\r\n    <script id=\"stripes-fragmentShader\" type=\"x-shader/x-vertex\">\r\n      #define GLSLIFY 1\r\n      // Common uniforms\r\n      uniform vec2 u_resolution;\r\n      uniform vec2 u_mouse;\r\n      uniform float u_time;\r\n      uniform float u_frame;\r\n\r\n      // Common varyings\r\n      varying vec3 v_position;\r\n      varying vec3 v_normal;\r\n\r\n      /*\r\n       *  Calculates the diffuse factor produced by the light illumination\r\n       */\r\n      float diffuseFactor(vec3 normal, vec3 light_direction) {\r\n          float df = dot(normalize(normal), normalize(light_direction));\r\n\r\n          if (gl_FrontFacing) {\r\n              df = -df;\r\n          }\r\n\r\n          return max(0.0, df);\r\n      }\r\n\r\n      /*\r\n       * The main program\r\n       */\r\n      void main() {\r\n          // Use the mouse position to define the light direction\r\n          float min_resolution = min(u_resolution.x, u_resolution.y);\r\n          vec3 light_direction = -vec3((u_mouse - 0.5 * u_resolution) / min_resolution, 0.5);\r\n\r\n          // Calculate the light diffusion factor\r\n          float df = diffuseFactor(v_normal, light_direction);\r\n\r\n          // Calculate the surface color\r\n          float surface_color = df;\r\n\r\n          // Don't paint the pixels between the stripes\r\n          if (cos(0.1 * v_position.y + 0.2 * u_time) < 0.0) {\r\n              discard;\r\n          }\r\n\r\n          // Fragment shader output\r\n          gl_FragColor = vec4(vec3(surface_color), 1.0);\r\n      }\r\n    </script>\r\n\r\n    <script id=\"pencil-vertexShader\" type=\"x-shader/x-vertex\">\r\n      #define GLSLIFY 1\r\n      // Common varyings\r\n      varying vec3 v_position;\r\n      varying vec3 v_normal;\r\n\r\n      /*\r\n      * The main program\r\n      */\r\n      void main() {\r\n          // Save the varyings\r\n          v_position = position;\r\n          v_normal = normalize(normalMatrix * normal);\r\n\r\n          // Vertex shader output\r\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    </script>\r\n\r\n    <script id=\"pencil-fragmentShader\" type=\"x-shader/x-vertex\">\r\n      #define GLSLIFY 1\r\n      // Common uniforms\r\n      uniform vec2 u_resolution;\r\n      uniform vec2 u_mouse;\r\n      uniform float u_time;\r\n      uniform float u_frame;\r\n\r\n      // Common varyings\r\n      varying vec3 v_position;\r\n      varying vec3 v_normal;\r\n\r\n      /*\r\n      * Returns a rotation matrix for the given angle\r\n      */\r\n      mat2 rotate(float angle) {\r\n          return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\r\n      }\r\n\r\n      /*\r\n      *  Calculates the diffuse factor produced by the light illumination\r\n      */\r\n      float diffuseFactor(vec3 normal, vec3 light_direction) {\r\n          float df = dot(normalize(normal), normalize(light_direction));\r\n\r\n          if (gl_FrontFacing) {\r\n              df = -df;\r\n          }\r\n\r\n          return max(0.0, df);\r\n      }\r\n\r\n      /*\r\n      * Returns a value between 1 and 0 that indicates if the pixel is inside the horizontal line\r\n      */\r\n      float horizontalLine(vec2 pixel, float y_pos, float width) {\r\n          return 1.0 - smoothstep(-1.0, 1.0, abs(pixel.y - y_pos) - 0.5 * width);\r\n      }\r\n\r\n      /*\r\n      * The main program\r\n      */\r\n      void main() {\r\n          // Use the mouse position to define the light direction\r\n          float min_resolution = min(u_resolution.x, u_resolution.y);\r\n          vec3 light_direction = -vec3((u_mouse - 0.5 * u_resolution) / min_resolution, 0.5);\r\n\r\n          // Calculate the light diffusion factor\r\n          float df = diffuseFactor(v_normal, light_direction);\r\n\r\n          // Move the pixel coordinates origin to the center of the screen\r\n          vec2 pos = gl_FragCoord.xy - 0.5 * u_resolution;\r\n\r\n          // Rotate the coordinates 20 degrees\r\n          pos = rotate(radians(20.0)) * pos;\r\n\r\n          // Define the first group of pencil lines\r\n          float line_width = 7.0 * (1.0 - smoothstep(0.0, 0.3, df)) + 0.5;\r\n          float lines_sep = 16.0;\r\n          vec2 grid_pos = vec2(pos.x, mod(pos.y, lines_sep));\r\n          float line_1 = horizontalLine(grid_pos, lines_sep / 2.0, line_width);\r\n          grid_pos.y = mod(pos.y + lines_sep / 2.0, lines_sep);\r\n          float line_2 = horizontalLine(grid_pos, lines_sep / 2.0, line_width);\r\n\r\n          // Rotate the coordinates 50 degrees\r\n          pos = rotate(radians(-50.0)) * pos;\r\n\r\n          // Define the second group of pencil lines\r\n          lines_sep = 12.0;\r\n          grid_pos = vec2(pos.x, mod(pos.y, lines_sep));\r\n          float line_3 = horizontalLine(grid_pos, lines_sep / 2.0, line_width);\r\n          grid_pos.y = mod(pos.y + lines_sep / 2.0, lines_sep);\r\n          float line_4 = horizontalLine(grid_pos, lines_sep / 2.0, line_width);\r\n\r\n          // Calculate the surface color\r\n          float surface_color = 1.0;\r\n          surface_color -= 0.8 * line_1 * (1.0 - smoothstep(0.5, 0.75, df));\r\n          surface_color -= 0.8 * line_2 * (1.0 - smoothstep(0.4, 0.5, df));\r\n          surface_color -= 0.8 * line_3 * (1.0 - smoothstep(0.4, 0.65, df));\r\n          surface_color -= 0.8 * line_4 * (1.0 - smoothstep(0.2, 0.4, df));\r\n          surface_color = clamp(surface_color, 0.05, 1.0);\r\n\r\n          // Fragment shader output\r\n          gl_FragColor = vec4(vec3(surface_color), 1.0);\r\n      }\r\n    </script>\r\n\r\n    <script id=\"fish-vertexShader\" type=\"x-shader/x-vertex\">\r\n      varying vec3 vNormal;\r\n      void main()\r\n      {\r\n           vNormal = normalize(normalMatrix * normal);\r\n           gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n      }\r\n    </script>\r\n\r\n    <!-- fragment shader a.k.a. pixel shader -->\r\n    <script id=\"fish-fragmentShader\" type=\"x-shader/x-vertex\">\r\n      uniform vec3 light;\r\n      varying vec3 vNormal;\r\n      uniform vec3 color;\r\n      void main()\r\n      {\r\n          float diffuse = dot(normalize(light), vNormal);\r\n          if (diffuse > 0.8) {\r\n          diffuse = 1.0;\r\n      }\r\n      else if (diffuse > 0.5) {\r\n          diffuse = 0.6;\r\n      }\r\n      else if (diffuse > 0.2) {\r\n          diffuse = 0.4;\r\n      }\r\n      else {\r\n          diffuse = 0.2;\r\n      }\r\n          gl_FragColor = vec4( color* diffuse, 1.0);\r\n      }\r\n    </script>\r\n\r\n    <script id=\"js-vertex-shader\" type=\"x-shader/x-vertex\">\r\n      attribute vec3 position;\r\n      attribute vec3 normal;\r\n      uniform mat4 modelViewMatrix;\r\n      uniform mat4 projectionMatrix;\r\n      uniform mat4 normalMatrix;\r\n      uniform float u_inflate;\r\n      uniform bool u_isEdge;\r\n      varying vec3 vNormal;\r\n\r\n      void main() {\r\n       vNormal =(normalMatrix * vec4(normal, 0.0)).xyz;\r\n       //頂点座標に法線方向に u_inflate 加算させる。\r\n       vec3 p = position;\r\n       if(u_isEdge == true){\r\n        p += normal * u_inflate;\r\n       }\r\n       gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );\r\n      }\r\n    </script>\r\n\r\n    <!-- fragmentShader -->\r\n    <script id=\"js-fragment-shader\" type=\"x-shader/x-fragment\">\r\n      precision mediump float;\r\n\r\n      uniform vec3 u_lightDirection;\r\n      uniform vec3 u_globalColor;\r\n      uniform float u_gradient;\r\n      uniform bool u_isEdge;\r\n      varying vec3 vNormal;\r\n\r\n      void main() {\r\n          vec3 light = normalize(u_lightDirection);\r\n          vec3 normal = normalize(vNormal);\r\n\r\n          if(u_isEdge == true){\r\n           vec3 rgb = vec3(0.0);\r\n           gl_FragColor = vec4(rgb, 1.0);\r\n          }\r\n\r\n          if(u_isEdge == false){\r\n              //法線の向きとベクトルの内積の結果から拡散光の計算する\r\n              //単位化された内積の結果は、-1.0 ~ 1.0になるので、\r\n              //(-1.0 ~ 1.0) * 0.5 + 0.5 == (0.0 ~ 1.0) の範囲に代わる\r\n              float luminance = dot(light, normal) * 0.5 + 0.5;\r\n\r\n              //情報の解像度を落とす\r\n              // floor(0.4 * 3.0) / 3.0 = 0.333\r\n              // floor(0.5 * 3.0) / 3.0 = 0.333\r\n              // floor(0.6 * 3.0) / 3.0 = 0.333\r\n              // floor(0.7 * 3.0) / 3.0 = 0.666\r\n              // 一定の範囲内では計算結果が同じになり、つまり解像度が落ちた状態になる\r\n              luminance = floor(luminance * u_gradient) / u_gradient;\r\n              vec3 rgb = vec3(u_globalColor * luminance);\r\n              gl_FragColor = vec4(rgb, 1.0);\r\n          }\r\n      }\r\n    </script>\r\n\r\n    <script src=\"/f41e9d04a45c83f3b6f6e630f10117fe.js\"></script>\r\n  </body>\r\n</html>\r\n"},"sourceMaps":null,"error":null,"hash":"d8acbc5a677597a08d0345167fd4fb94","cacheData":{}}